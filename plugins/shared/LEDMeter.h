#pragma once

// Support both JuceHeader.h (generated by juce_generate_juce_header) and direct module includes
#if __has_include(<JuceHeader.h>)
    #include <JuceHeader.h>
#else
    #include <juce_gui_basics/juce_gui_basics.h>
    #include <juce_audio_basics/juce_audio_basics.h>
#endif

//==============================================================================
/**
 * Professional LED-style level meter component
 * Used for input/output level metering in audio plugins
 *
 * Features:
 * - Color-coded LEDs (green/yellow/red) with realistic glow effects
 * - Vertical or horizontal orientation
 * - Glow effects and highlights for realistic LED appearance
 * - Visible unlit LEDs (dim but present, like real hardware)
 * - -60dB to +6dB range
 * - VU-style ballistics (smooth attack/release)
 * - Peak hold indicator with configurable hold time
 * - Auto stereo mode: automatically shows L/R when stereo levels differ
 * - Manual stereo mode override available
 */
class LEDMeter : public juce::Component
{
public:
    enum Orientation { Vertical, Horizontal };

    explicit LEDMeter(Orientation orient = Vertical);

    /** Set the current level in dB (-60 to +6 dB) - applies VU ballistics
     *  For mono mode or when stereo levels are identical */
    void setLevel(float newLevel);

    /** Set stereo levels in dB (-60 to +6 dB) - applies VU ballistics
     *  Automatically enables stereo display when L/R differ */
    void setStereoLevels(float leftLevel, float rightLevel);

    /** Enable/disable stereo mode (shows L and R as separate bars)
     *  When set to true, forces stereo display even with identical levels
     *  When set to false, uses auto-detection based on level differences */
    void setStereoMode(bool enabled) { stereoModeForced = enabled; stereoMode = enabled; repaint(); }

    /** Check if stereo mode is currently active */
    bool isStereoMode() const { return stereoMode; }

    /** Set the sample rate for accurate ballistics timing */
    void setSampleRate(double sampleRate);

    /** Set the UI refresh rate (how often setLevel is called per second) */
    void setRefreshRate(float rateHz);

    /** Enable/disable peak hold indicator */
    void setPeakHoldEnabled(bool enabled) { peakHoldEnabled = enabled; }

    /** Set peak hold time in seconds (default 1.5s) */
    void setPeakHoldTime(float seconds) { peakHoldTimeSeconds = seconds; updateBallisticsCoefficients(); }

    /** Paint the LED meter */
    void paint(juce::Graphics& g) override;

private:
    Orientation orientation;
    bool stereoMode = false;          // Current stereo display state
    bool stereoModeForced = false;    // When true, always show stereo

    // Mono/combined levels
    float currentLevel = -60.0f;      // Raw input level
    float displayLevel = -60.0f;      // Smoothed display level (with ballistics)

    // Stereo levels (L/R)
    float currentLevelL = -60.0f;     // Raw left level
    float currentLevelR = -60.0f;     // Raw right level
    float displayLevelL = -60.0f;     // Smoothed left display level
    float displayLevelR = -60.0f;     // Smoothed right display level

    static constexpr int numLEDs = 12;

    // VU Ballistics parameters
    float attackCoeff = 0.0f;   // How fast meter rises
    float releaseCoeff = 0.0f;  // How fast meter falls
    float refreshRateHz = 30.0f;  // UI refresh rate

    // Peak hold parameters (mono)
    bool peakHoldEnabled = true;        // Peak hold on by default
    float peakHoldTimeSeconds = 1.5f;   // How long to hold peak
    float peakLevel = -60.0f;           // Current peak hold level
    int peakHoldCounter = 0;            // Counts down from hold time
    int peakHoldSamples = 0;            // Number of UI frames to hold peak

    // Peak hold parameters (stereo L/R)
    float peakLevelL = -60.0f;
    float peakLevelR = -60.0f;
    int peakHoldCounterL = 0;
    int peakHoldCounterR = 0;

    // LED color structure
    struct LEDColors {
        juce::Colour litColor;
        juce::Colour unlitColor;
        juce::Colour glowColor;
    };

    void updateBallisticsCoefficients();
    float applyBallistics(float currentLevel, float displayLevel);
    void updatePeakHold(float currentLevel, float displayLevel, float& peakLevel, int& peakHoldCounter);

    /** Get colors for a specific LED segment based on its position */
    LEDColors getColorsForSegment(int segmentIndex) const;

    /** Draw a single LED segment with proper lit/unlit/peak states */
    void drawLEDSegment(juce::Graphics& g, juce::Rectangle<float> bounds,
                        bool isLit, bool isPeak, const LEDColors& colors) const;

    /** Paint a single column of LEDs (vertical orientation) */
    void paintVerticalColumn(juce::Graphics& g, juce::Rectangle<float> bounds,
                             float displayLevel, float peakLevel);

    /** Paint a single row of LEDs (horizontal orientation) */
    void paintHorizontalRow(juce::Graphics& g, juce::Rectangle<float> bounds,
                            float displayLevel, float peakLevel);

    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(LEDMeter)
};
