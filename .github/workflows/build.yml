name: Build Plugins

on:
  push:
    tags:
      - 'v*'                    # Full release: v1.0.0 builds all plugins
      - '4k-eq-v*'              # 4K EQ only: 4k-eq-v1.0.0
      - 'multi-comp-v*'         # Multi-Comp only: multi-comp-v1.0.1
      - 'tapemachine-v*'        # TapeMachine only
      - 'tape-echo-v*'          # Tape Echo only
      - 'velvet-90-v*'           # Velvet 90 only
      - 'suede-200-v*'          # Suede 200 only
      - 'multi-q-v*'            # Multi-Q only
      - 'convolution-reverb-v*' # Convolution Reverb only
      - 'neural-amp-v*'         # Neural Amp only
      - 'groovemind-v*'         # GrooveMind only
  workflow_dispatch:
    inputs:
      plugin:
        description: 'Plugin to build (leave empty for all)'
        required: false
        default: ''
        type: choice
        options:
          - ''
          - '4k-eq'
          - 'multi-comp'
          - 'tapemachine'
          - 'tape-echo'
          - 'velvet-90'
          - 'suede-200'
          - 'multi-q'
          - 'convolution-reverb'
          - 'neural-amp'
          - 'groovemind'

env:
  BUILD_TYPE: Release

jobs:
  # Determine which plugin(s) to build based on tag
  setup:
    runs-on: ubuntu-latest
    outputs:
      plugin_target: ${{ steps.parse.outputs.target }}
      plugin_name: ${{ steps.parse.outputs.name }}
      release_name: ${{ steps.parse.outputs.release_name }}
      is_release: ${{ steps.parse.outputs.is_release }}
      plugin_version: ${{ steps.parse.outputs.version }}
    steps:
      - name: Parse tag for plugin selection
        id: parse
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          MANUAL_PLUGIN="${{ github.event.inputs.plugin }}"

          # Default: build all
          TARGET=""
          NAME="All Plugins"
          RELEASE_NAME="DuskAudio-Plugins"
          IS_RELEASE="false"
          VERSION=""

          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            IS_RELEASE="true"
            # Extract version from tag (e.g., "4k-eq-v1.0.5" -> "1.0.5")
            VERSION=$(echo "$TAG" | sed 's/.*-v//')
            echo "Extracted version from tag: $VERSION"

            if [[ "$TAG" == 4k-eq-v* ]]; then
              TARGET="FourKEQ_All"
              NAME="4K EQ"
              RELEASE_NAME="4k-eq"
            elif [[ "$TAG" == multi-comp-v* ]]; then
              TARGET="MultiComp_All"
              NAME="Multi-Comp"
              RELEASE_NAME="multi-comp"
            elif [[ "$TAG" == tapemachine-v* ]]; then
              TARGET="TapeMachine_All"
              NAME="TapeMachine"
              RELEASE_NAME="tapemachine"
            elif [[ "$TAG" == velvet-90-v* ]]; then
              TARGET="Velvet90_All"
              NAME="Velvet 90"
              RELEASE_NAME="velvet-90"
            elif [[ "$TAG" == multi-q-v* ]]; then
              TARGET="MultiQ_All"
              NAME="Multi-Q"
              RELEASE_NAME="multi-q"
            elif [[ "$TAG" == tape-echo-v* ]]; then
              TARGET="TapeEcho_All"
              NAME="Tape Echo"
              RELEASE_NAME="tape-echo"
            elif [[ "$TAG" == convolution-reverb-v* ]]; then
              TARGET="ConvolutionReverb_All"
              NAME="Convolution Reverb"
              RELEASE_NAME="convolution-reverb"
            elif [[ "$TAG" == neural-amp-v* ]]; then
              TARGET="NeuralAmp_All"
              NAME="Neural Amp"
              RELEASE_NAME="neural-amp"
            elif [[ "$TAG" == groovemind-v* ]]; then
              TARGET="GrooveMind_All"
              NAME="GrooveMind"
              RELEASE_NAME="groovemind"
            elif [[ "$TAG" == suede-200-v* ]]; then
              TARGET="Suede200_All"
              NAME="Suede 200"
              RELEASE_NAME="suede-200"
            fi
          elif [[ -n "$MANUAL_PLUGIN" ]]; then
            case "$MANUAL_PLUGIN" in
              4k-eq) TARGET="FourKEQ_All"; NAME="4K EQ"; RELEASE_NAME="4k-eq" ;;
              multi-comp) TARGET="MultiComp_All"; NAME="Multi-Comp"; RELEASE_NAME="multi-comp" ;;
              tapemachine) TARGET="TapeMachine_All"; NAME="TapeMachine"; RELEASE_NAME="tapemachine" ;;
              tape-echo) TARGET="TapeEcho_All"; NAME="Tape Echo"; RELEASE_NAME="tape-echo" ;;
              velvet-90) TARGET="Velvet90_All"; NAME="Velvet 90"; RELEASE_NAME="velvet-90" ;;
              multi-q) TARGET="MultiQ_All"; NAME="Multi-Q"; RELEASE_NAME="multi-q" ;;
              convolution-reverb) TARGET="ConvolutionReverb_All"; NAME="Convolution Reverb"; RELEASE_NAME="convolution-reverb" ;;
              neural-amp) TARGET="NeuralAmp_All"; NAME="Neural Amp"; RELEASE_NAME="neural-amp" ;;
              groovemind) TARGET="GrooveMind_All"; NAME="GrooveMind"; RELEASE_NAME="groovemind" ;;
              suede-200) TARGET="Suede200_All"; NAME="Suede 200"; RELEASE_NAME="suede-200" ;;
            esac
          fi

          echo "target=$TARGET" >> $GITHUB_OUTPUT
          echo "name=$NAME" >> $GITHUB_OUTPUT
          echo "release_name=$RELEASE_NAME" >> $GITHUB_OUTPUT
          echo "is_release=$IS_RELEASE" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building: $NAME (target: ${TARGET:-all}) version: ${VERSION:-default}"

  build-linux:
    needs: setup
    runs-on: ubuntu-latest
    timeout-minutes: 30
    container:
      image: ubuntu:20.04  # Use Ubuntu 20.04 for glibc 2.31 (widest compatibility)
    steps:
      - name: Install git and dependencies
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          apt-get update
          apt-get install -y --no-install-recommends git ca-certificates software-properties-common

      - name: Install GCC 11 toolchain
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          add-apt-repository -y ppa:ubuntu-toolchain-r/test
          apt-get update
          apt-get install -y gcc-11 g++-11
          # Set GCC 11 as default for all compiler symlinks
          update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-11 100
          update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-11 100
          update-alternatives --install /usr/bin/cc cc /usr/bin/gcc-11 100
          update-alternatives --install /usr/bin/c++ c++ /usr/bin/g++-11 100
          gcc --version
          g++ --version

      - name: Install modern CMake
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          # Install CMake 3.28 from Kitware's APT repo (JUCE 8 requires 3.22+)
          apt-get install -y wget
          wget -O - https://apt.kitware.com/keys/kitware-archive-latest.asc 2>/dev/null | gpg --dearmor - | tee /usr/share/keyrings/kitware-archive-keyring.gpg >/dev/null
          echo 'deb [signed-by=/usr/share/keyrings/kitware-archive-keyring.gpg] https://apt.kitware.com/ubuntu/ focal main' | tee /etc/apt/sources.list.d/kitware.list >/dev/null
          apt-get update
          apt-get install -y cmake
          cmake --version

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Checkout JUCE
        uses: actions/checkout@v4
        with:
          repository: juce-framework/JUCE
          path: JUCE
          ref: 8.0.4  # Use JUCE 8.x for modern C++ features

      - name: Install Linux dependencies
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          apt-get install -y --no-install-recommends \
            build-essential \
            cmake \
            pkg-config \
            libasound2-dev \
            libjack-jackd2-dev \
            ladspa-sdk \
            libcurl4-openssl-dev \
            libfreetype6-dev \
            libx11-dev \
            libxcomposite-dev \
            libxcursor-dev \
            libxext-dev \
            libxinerama-dev \
            libxrandr-dev \
            libxrender-dev \
            libwebkit2gtk-4.0-dev \
            libglu1-mesa-dev \
            mesa-common-dev

      - name: Configure CMake
        run: |
          if [ -n "${{ needs.setup.outputs.plugin_version }}" ]; then
            export PLUGIN_VERSION_OVERRIDE="${{ needs.setup.outputs.plugin_version }}"
          fi
          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DDUSK_COPY_AFTER_BUILD=OFF \
            -DJUCE_PATH=$(pwd)/JUCE

      - name: Build plugins
        run: |
          if [ -n "${{ needs.setup.outputs.plugin_version }}" ]; then
            export PLUGIN_VERSION_OVERRIDE="${{ needs.setup.outputs.plugin_version }}"
          fi
          TARGET="${{ needs.setup.outputs.plugin_target }}"
          if [ -n "$TARGET" ]; then
            echo "Building specific target: $TARGET"
            cmake --build build --config ${{ env.BUILD_TYPE }} --target $TARGET -j$(nproc)
          else
            echo "Building all plugins"
            cmake --build build --config ${{ env.BUILD_TYPE }} -j$(nproc)
          fi

      - name: Validate plugins
        shell: bash
        run: |
          echo "=== Validating Linux plugin builds ==="
          found_vst3=0
          found_lv2=0

          # Search build/lib, build/bin, and build/plugins (artefacts directories) for plugin outputs
          # Different plugins may output to different locations depending on CMakeLists.txt configuration
          while IFS= read -r -d '' vst3; do
            # Skip if no binary exists
            if ! ls "$vst3/Contents/x86_64-linux/"*.so >/dev/null 2>&1; then
              echo "⊘ Skipping (no binary): $vst3"
              continue
            fi
            echo "✓ Found: $vst3"
            found_vst3=1
            echo "  ✓ Binary exists"
          done < <(find build/lib build/bin build/plugins -name "*.vst3" -type d -print0 2>/dev/null)

          while IFS= read -r -d '' lv2; do
            # Skip if no binary exists
            if ! ls "$lv2/"*.so >/dev/null 2>&1; then
              echo "⊘ Skipping (no binary): $lv2"
              continue
            fi
            echo "✓ Found: $lv2"
            found_lv2=1
            if [ -f "$lv2/manifest.ttl" ]; then
              echo "  ✓ Binary and manifest exist"
            else
              echo "  ⚠ Missing manifest.ttl"
            fi
          done < <(find build/lib build/bin build/plugins -name "*.lv2" -type d -print0 2>/dev/null)

          # Fail if no plugins were found
          if [ $found_vst3 -eq 0 ]; then
            echo "✗ No VST3 plugins found!"
            exit 1
          fi

          if [ $found_lv2 -eq 0 ]; then
            echo "✗ No LV2 plugins found!"
            exit 1
          fi

          echo "=== Validation passed ==="

      - name: Prepare artifacts
        shell: bash
        run: |
          mkdir -p artifacts/linux/VST3 artifacts/linux/LV2

          # Copy VST3 plugins from build/lib/, build/bin/, and build/plugins/ (handles spaces in names)
          find build/lib build/bin build/plugins -name "*.vst3" -type d -print0 2>/dev/null | while IFS= read -r -d '' vst3; do
            if ls "$vst3/Contents/x86_64-linux/"*.so >/dev/null 2>&1; then
              cp -r "$vst3" artifacts/linux/VST3/
            fi
          done

          # Copy LV2 plugins from build/lib/, build/bin/, and build/plugins/ (handles spaces in names)
          find build/lib build/bin build/plugins -name "*.lv2" -type d -print0 2>/dev/null | while IFS= read -r -d '' lv2; do
            if ls "$lv2/"*.so >/dev/null 2>&1; then
              cp -r "$lv2" artifacts/linux/LV2/
            fi
          done

          # List what we collected
          echo "=== Linux Artifacts ==="
          find artifacts/linux -type f -name "*.so" | head -20

      - name: Upload Linux artifacts
        uses: actions/upload-artifact@v4
        with:
          name: plugins-linux
          path: artifacts/linux/
          retention-days: 30

  build-windows:
    needs: setup
    runs-on: windows-latest
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Checkout JUCE
        uses: actions/checkout@v4
        with:
          repository: juce-framework/JUCE
          path: JUCE
          ref: 8.0.4  # Use JUCE 8.x for modern C++ features

      - name: Configure CMake
        run: |
          if ("${{ needs.setup.outputs.plugin_version }}") {
            $env:PLUGIN_VERSION_OVERRIDE = "${{ needs.setup.outputs.plugin_version }}"
          }
          cmake -B build `
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} `
            -DDUSK_COPY_AFTER_BUILD=OFF `
            -DJUCE_PATH=${{ github.workspace }}/JUCE

      - name: Build plugins
        run: |
          if ("${{ needs.setup.outputs.plugin_version }}") {
            $env:PLUGIN_VERSION_OVERRIDE = "${{ needs.setup.outputs.plugin_version }}"
          }
          $target = "${{ needs.setup.outputs.plugin_target }}"
          if ($target) {
            Write-Host "Building specific target: $target"
            cmake --build build --config ${{ env.BUILD_TYPE }} --target $target -j $env:NUMBER_OF_PROCESSORS
          } else {
            Write-Host "Building all plugins"
            cmake --build build --config ${{ env.BUILD_TYPE }} -j $env:NUMBER_OF_PROCESSORS
          }

      - name: Validate plugins
        shell: pwsh
        run: |
          Write-Host "=== Validating Windows plugin builds ==="
          $foundVst3 = $false

          # Check VST3 plugins in build/lib/, build/bin/, and build/plugins/ (artefacts directories)
          $searchPaths = @("build/lib", "build/bin", "build/plugins")
          foreach ($searchPath in $searchPaths) {
            $vst3s = Get-ChildItem -Path $searchPath -Recurse -Filter "*.vst3" -Directory -ErrorAction SilentlyContinue
            foreach ($vst3 in $vst3s) {
              # Check if the plugin has a .vst3 binary file inside
              $binaryFile = Get-ChildItem -Path $vst3.FullName -Recurse -Filter "*.vst3" -File -ErrorAction SilentlyContinue
              if (-not $binaryFile) {
                Write-Host "⊘ Skipping (no binary): $($vst3.FullName)"
                continue
              }
              Write-Host "✓ Found: $($vst3.FullName)"
              Write-Host "  ✓ Binary exists: $($binaryFile.FullName)"
              $foundVst3 = $true
            }
          }

          if (-not $foundVst3) {
            Write-Host "✗ No VST3 plugins with binaries found!"
            Write-Host "=== Debug: Searching entire build directory ==="
            Get-ChildItem -Path build -Recurse -Filter "*.vst3" | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }

          Write-Host "=== Validation passed ==="

      - name: Prepare artifacts
        shell: pwsh
        run: |
          New-Item -ItemType Directory -Force -Path artifacts/windows/VST3

          # Copy VST3 plugins from build/lib/, build/bin/, and build/plugins/ that have actual binaries
          $searchPaths = @("build/lib", "build/bin", "build/plugins")
          foreach ($searchPath in $searchPaths) {
            $vst3s = Get-ChildItem -Path $searchPath -Recurse -Filter "*.vst3" -Directory -ErrorAction SilentlyContinue
            foreach ($vst3 in $vst3s) {
              # Check if the plugin has a .vst3 binary file inside
              $binaryFile = Get-ChildItem -Path $vst3.FullName -Recurse -Filter "*.vst3" -File -ErrorAction SilentlyContinue
              if ($binaryFile) {
                Write-Host "Copying: $($vst3.FullName)"
                Copy-Item -Path $vst3.FullName -Destination "artifacts/windows/VST3/" -Recurse
              } else {
                Write-Host "Skipping (no binary): $($vst3.FullName)"
              }
            }
          }

          Write-Host "=== Windows Artifacts ==="
          Get-ChildItem -Path artifacts/windows -Recurse -Filter "*.vst3" | Select-Object FullName

      - name: Upload Windows artifacts
        uses: actions/upload-artifact@v4
        with:
          name: plugins-windows
          path: artifacts/windows/
          retention-days: 30

  build-macos:
    needs: setup
    runs-on: macos-14  # ARM64 runner (M1)
    timeout-minutes: 30
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Checkout JUCE
        uses: actions/checkout@v4
        with:
          repository: juce-framework/JUCE
          path: JUCE
          ref: 8.0.4  # Use JUCE 8.x for modern C++ features

      - name: Configure CMake (Universal Binary)
        run: |
          if [ -n "${{ needs.setup.outputs.plugin_version }}" ]; then
            export PLUGIN_VERSION_OVERRIDE="${{ needs.setup.outputs.plugin_version }}"
          fi
          cmake -B build \
            -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} \
            -DDUSK_COPY_AFTER_BUILD=OFF \
            -DCMAKE_OSX_ARCHITECTURES="arm64;x86_64" \
            -DCMAKE_OSX_DEPLOYMENT_TARGET="10.15" \
            -DJUCE_PATH=${{ github.workspace }}/JUCE

      - name: Build plugins
        run: |
          if [ -n "${{ needs.setup.outputs.plugin_version }}" ]; then
            export PLUGIN_VERSION_OVERRIDE="${{ needs.setup.outputs.plugin_version }}"
          fi
          TARGET="${{ needs.setup.outputs.plugin_target }}"
          if [ -n "$TARGET" ]; then
            echo "Building specific target: $TARGET"
            cmake --build build --config ${{ env.BUILD_TYPE }} --target $TARGET -j$(sysctl -n hw.ncpu)
          else
            echo "Building all plugins"
            cmake --build build --config ${{ env.BUILD_TYPE }} -j$(sysctl -n hw.ncpu)
          fi

      - name: Validate plugins
        run: |
          echo "=== Validating macOS plugin builds ==="
          found_vst3=0
          found_au=0

          # Search build/lib, build/bin, and build/plugins (artefacts directories) for plugin outputs
          while IFS= read -r -d '' vst3; do
            # Verify binary exists - look for the binary inside Contents/MacOS
            plugin_name=$(basename "$vst3" .vst3)
            binary="$vst3/Contents/MacOS/$plugin_name"
            if [ ! -f "$binary" ]; then
              echo "⊘ Skipping (no binary): $vst3"
              continue
            fi
            echo "✓ Found: $vst3"
            found_vst3=1
            archs=$(lipo -info "$binary" 2>/dev/null || file "$binary")
            echo "  Architectures: $archs"
            if echo "$archs" | grep -q "arm64" && echo "$archs" | grep -q "x86_64"; then
              echo "  ✓ Universal binary confirmed"
            else
              echo "  ⚠ May not be universal binary"
            fi
          done < <(find build/lib build/bin build/plugins -name "*.vst3" -type d -print0 2>/dev/null)

          # Check AU plugins
          while IFS= read -r -d '' au; do
            plugin_name=$(basename "$au" .component)
            if [ ! -f "$au/Contents/MacOS/$plugin_name" ]; then
              echo "⊘ Skipping AU (no binary): $au"
              continue
            fi
            echo "✓ Found AU: $au"
            found_au=1
          done < <(find build/lib build/bin build/plugins -name "*.component" -type d -print0 2>/dev/null)

          # Fail if no plugins were found
          if [ $found_vst3 -eq 0 ]; then
            echo "✗ No VST3 plugins found!"
            exit 1
          fi

          echo "=== Validation passed ==="

      - name: Import Code Signing Certificate
        if: ${{ vars.MACOS_SIGNING_ENABLED == 'true' }}
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          security create-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH

          # Import certificate
          echo $MACOS_CERTIFICATE | base64 --decode > certificate.p12
          security import certificate.p12 -P "$MACOS_CERTIFICATE_PWD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$KEYCHAIN_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          rm certificate.p12

      - name: Code Sign Plugins
        if: ${{ vars.MACOS_SIGNING_ENABLED == 'true' }}
        env:
          MACOS_SIGNING_IDENTITY: ${{ secrets.MACOS_SIGNING_IDENTITY }}
        run: |
          echo "=== Code Signing macOS Plugins ==="

          # Sign VST3 plugins
          for plugin in build/*_artefacts/Release/VST3/*.vst3; do
            if [ -d "$plugin" ]; then
              echo "Signing: $plugin"
              codesign --force --deep --sign "$MACOS_SIGNING_IDENTITY" \
                --options runtime \
                --timestamp \
                "$plugin"

              # Verify signature
              codesign --verify --verbose "$plugin"
            fi
          done

          # Sign AU plugins
          for plugin in build/*_artefacts/Release/AU/*.component; do
            if [ -d "$plugin" ]; then
              echo "Signing: $plugin"
              codesign --force --deep --sign "$MACOS_SIGNING_IDENTITY" \
                --options runtime \
                --timestamp \
                "$plugin"

              codesign --verify --verbose "$plugin"
            fi
          done

      - name: Notarize Plugins
        if: ${{ vars.MACOS_SIGNING_ENABLED == 'true' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_PASSWORD: ${{ secrets.APPLE_APP_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          echo "=== Notarizing macOS Plugins ==="

          # Create zip for notarization
          cd build

          # Collect all signed plugins
          mkdir -p notarize_staging
          find . -path "*Release/VST3/*.vst3" -type d -exec cp -r {} notarize_staging/ \;
          find . -path "*Release/AU/*.component" -type d -exec cp -r {} notarize_staging/ \;

          # Create submission zip
          ditto -c -k --keepParent notarize_staging plugins-macos-notarize.zip

          # Submit for notarization
          xcrun notarytool submit plugins-macos-notarize.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait

          # Staple the notarization ticket to each plugin
          for plugin in notarize_staging/*.vst3 notarize_staging/*.component; do
            if [ -d "$plugin" ]; then
              echo "Stapling: $plugin"
              xcrun stapler staple "$plugin"
            fi
          done

          cd ..

      - name: Prepare artifacts
        shell: bash
        run: |
          mkdir -p artifacts/macos/VST3 artifacts/macos/AU

          # Copy plugins (use notarized versions if available)
          if [ -d "build/notarize_staging" ]; then
            cp -r build/notarize_staging/*.vst3 artifacts/macos/VST3/ 2>/dev/null || true
            cp -r build/notarize_staging/*.component artifacts/macos/AU/ 2>/dev/null || true
          else
            # Copy VST3 plugins from build/lib/, build/bin/, and build/plugins/ (handles spaces in names)
            find build/lib build/bin build/plugins -name "*.vst3" -type d -print0 2>/dev/null | while IFS= read -r -d '' vst3; do
              plugin_name=$(basename "$vst3" .vst3)
              if [ -f "$vst3/Contents/MacOS/$plugin_name" ]; then
                cp -r "$vst3" artifacts/macos/VST3/
              fi
            done

            # Copy AU plugins from build/lib/, build/bin/, and build/plugins/ (handles spaces in names)
            find build/lib build/bin build/plugins -name "*.component" -type d -print0 2>/dev/null | while IFS= read -r -d '' au; do
              plugin_name=$(basename "$au" .component)
              if [ -f "$au/Contents/MacOS/$plugin_name" ]; then
                cp -r "$au" artifacts/macos/AU/
              fi
            done
          fi

          echo "=== macOS Artifacts ==="
          find artifacts/macos -type d \( -name "*.vst3" -o -name "*.component" \)

      - name: Upload macOS artifacts
        uses: actions/upload-artifact@v4
        with:
          name: plugins-macos
          path: artifacts/macos/
          retention-days: 30

  # Create release when a tag is pushed
  release:
    needs: [setup, build-linux, build-windows, build-macos]
    runs-on: ubuntu-latest
    if: needs.setup.outputs.is_release == 'true'
    permissions:
      contents: write
    steps:
      - name: Checkout repository (for tag message)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create release archives
        env:
          RELEASE_NAME: ${{ needs.setup.outputs.release_name }}
          PLUGIN_NAME: ${{ needs.setup.outputs.plugin_name }}
        run: |
          cd artifacts

          # Extract version from tag (remove plugin prefix if present)
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION=$(echo "$TAG" | sed 's/.*-v/v/' | sed 's/^v//')

          # Create lowercase slug for zip naming (Multi-Comp -> multi-comp)
          SLUG=$(echo "$RELEASE_NAME" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')

          echo "=== Creating release archives ==="
          echo "Plugin: $PLUGIN_NAME"
          echo "Release name: $RELEASE_NAME"
          echo "Slug: $SLUG"
          echo "Version: $VERSION"

          # Linux: Create zip with VST3/ and LV2/ folders at root (not nested in plugins-linux/)
          # This allows users to extract directly and copy the appropriate format
          mkdir -p linux-release
          if [ -d "plugins-linux/VST3" ]; then
            cp -r plugins-linux/VST3 linux-release/
          fi
          if [ -d "plugins-linux/LV2" ]; then
            cp -r plugins-linux/LV2 linux-release/
          fi
          cd linux-release
          zip -r "../../${SLUG}-linux.zip" .
          cd ..

          # Windows: Create zip with VST3/ folder at root
          mkdir -p windows-release
          if [ -d "plugins-windows/VST3" ]; then
            cp -r plugins-windows/VST3 windows-release/
          fi
          cd windows-release
          zip -r "../../${SLUG}-windows.zip" .
          cd ..

          # macOS: Create zip with VST3/ and AU/ folders at root
          mkdir -p macos-release
          if [ -d "plugins-macos/VST3" ]; then
            cp -r plugins-macos/VST3 macos-release/
          fi
          if [ -d "plugins-macos/AU" ]; then
            cp -r plugins-macos/AU macos-release/
          fi
          cd macos-release
          zip -r "../../${SLUG}-macos.zip" .
          cd ..

          # List contents for verification
          echo "=== Release Archives ==="
          ls -la ../*.zip
          echo ""
          echo "=== Linux archive contents ==="
          unzip -l "../${SLUG}-linux.zip" | head -30
          echo ""
          echo "=== Windows archive contents ==="
          unzip -l "../${SLUG}-windows.zip" | head -30
          echo ""
          echo "=== macOS archive contents ==="
          unzip -l "../${SLUG}-macos.zip" | head -30

      - name: Create GitHub Release
        env:
          RELEASE_NAME: ${{ needs.setup.outputs.release_name }}
          PLUGIN_NAME: ${{ needs.setup.outputs.plugin_name }}
        run: |
          TAG="${GITHUB_REF#refs/tags/}"
          VERSION=$(echo "$TAG" | sed 's/.*-v/v/' | sed 's/^v//')

          # Extract changelog from annotated tag message (skip the first line which is the title)
          TAG_MESSAGE=$(git tag -l --format='%(contents)' "$TAG" 2>/dev/null || echo "")
          # Remove the first line (tag title like "4K EQ v1.0.8") to avoid duplication with release title
          CHANGELOG=$(echo "$TAG_MESSAGE" | tail -n +2 | sed '/^$/d; 1{/^$/d}')

          # Build release body with changelog + installation instructions
          {
            echo "## ${PLUGIN_NAME} v${VERSION}"
            echo ""

            # Include changelog from tag if available
            if [ -n "$CHANGELOG" ]; then
              echo "$CHANGELOG"
              echo ""
            fi

            echo "### Installation"
            echo ""
            echo "Each zip contains \`VST3/\` and \`LV2/\` (Linux) or \`AU/\` (macOS) folders."
            echo ""
            echo "**Linux:**"
            echo "- VST3: Copy the \`.vst3\` folder from \`VST3/\` to \`~/.vst3/\`"
            echo "- LV2: Copy the \`.lv2\` folder from \`LV2/\` to \`~/.lv2/\`"
            echo ""
            echo "**Windows:**"
            echo "- VST3: Copy the \`.vst3\` folder from \`VST3/\` to \`C:\\Program Files\\Common Files\\VST3\\\`"
            echo ""
            echo "**macOS:**"
            echo "- VST3: Copy the \`.vst3\` bundle from \`VST3/\` to \`/Library/Audio/Plug-Ins/VST3/\` or \`~/Library/Audio/Plug-Ins/VST3/\`"
            echo "- AU: Copy the \`.component\` bundle from \`AU/\` to \`/Library/Audio/Plug-Ins/Components/\` or \`~/Library/Audio/Plug-Ins/Components/\`"

            # Add plugin list for "all plugins" releases
            if [ "$PLUGIN_NAME" = "All Plugins" ]; then
              echo ""
              echo "### Included Plugins"
              echo "- 4K EQ - Classic British Console EQ Emulation"
              echo "- Multi-Comp - Multi-mode compressor with multiband"
              echo "- TapeMachine - Analog tape machine emulation"
              echo "- Velvet 90 - Algorithmic reverb"
              echo "- Convolution Reverb - IR-based reverb"
              echo "- Multi-Q - Universal 8-band EQ"
              echo "- And more..."
            fi
          } > release_body.md

      - name: Publish Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            *.zip
          generate_release_notes: true
          body_path: release_body.md
          draft: false
          prerelease: ${{ contains(github.ref, '-beta') || contains(github.ref, '-alpha') || contains(github.ref, '-rc') }}

      - name: Update Website Version
        if: ${{ needs.setup.outputs.plugin_name != 'All Plugins' }}
        env:
          RELEASE_NAME: ${{ needs.setup.outputs.release_name }}
          PLUGIN_VERSION: ${{ needs.setup.outputs.plugin_version }}
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: |
          # Skip if no PAT configured or no version
          if [ -z "$GH_TOKEN" ] || [ -z "$PLUGIN_VERSION" ]; then
            echo "Skipping website update (no PAT or version)"
            exit 0
          fi

          echo "Updating website with $RELEASE_NAME version $PLUGIN_VERSION"

          # Clone website repo
          git clone https://x-access-token:${GH_TOKEN}@github.com/dusk-audio/dusk-audio.github.io.git website
          cd website

          # Update version in plugins.yml using sed
          # Format: "  version: X.X.X" under the plugin entry
          PLUGIN_SLUG="$RELEASE_NAME"

          # Update version in the plugin's markdown file (front matter)
          # This is where Jekyll reads the version from
          PLUGIN_MD="_plugins/${PLUGIN_SLUG}.md"
          if [ -f "$PLUGIN_MD" ]; then
            echo "Updating $PLUGIN_MD"
            if grep -q "^version:" "$PLUGIN_MD"; then
              sed -i "s/^version: .*/version: \"$PLUGIN_VERSION\"/" "$PLUGIN_MD"
            else
              echo "Warning: No version field found in $PLUGIN_MD"
            fi
          else
            echo "Warning: $PLUGIN_MD not found"
          fi

          # Update _data/plugins.yml using sed (preserves formatting, no yaml.dump)
          SLUG_LINE=$(grep -n "slug: ${PLUGIN_SLUG}$" _data/plugins.yml | head -1 | cut -d: -f1)
          if [ -n "$SLUG_LINE" ]; then
            # Find and update the version line within 10 lines after the slug
            sed -i "${SLUG_LINE},$((SLUG_LINE + 10))s/version: .*/version: ${PLUGIN_VERSION}/" _data/plugins.yml
            echo "Updated $PLUGIN_SLUG to version $PLUGIN_VERSION in plugins.yml"
          else
            echo "Warning: Plugin '$PLUGIN_SLUG' not found in plugins.yml"
          fi

          # Check if there are changes
          if git diff --quiet; then
            echo "No changes to commit"
            exit 0
          fi

          # Commit and push
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add _data/plugins.yml
          if [ -f "_plugins/${PLUGIN_SLUG}.md" ] && ! git diff --quiet "_plugins/${PLUGIN_SLUG}.md"; then
            git add "_plugins/${PLUGIN_SLUG}.md"
          fi
          git commit -m "Update $RELEASE_NAME to v$PLUGIN_VERSION

          Automated update from release workflow."
          git push
